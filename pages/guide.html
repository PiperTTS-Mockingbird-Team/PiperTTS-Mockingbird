<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GRAPE | User Guide</title>
  <style>
    :root {
      --primary-light: #c39be0;
      --primary-dark: #8b5fbf;
      --bg-light: #ffffff;
      --bg-dark: #1e1e2f;
      --text-light: #222;
      --text-dark: #f2f2f2;
      --accent: #d6b3f2;
    }
    @media (prefers-color-scheme: dark) {
      body { background-color: rgba(255, 255, 255, 0.85); color: var(--text-dark); }
      summary { color: var(--primary-light); }
    }
    @media (prefers-color-scheme: light) {
      body { background-color: rgba(255, 255, 255, 0.85); color: var(--text-light); }
      summary { color: var(--primary-dark); }
    }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      padding: 30px;
      max-width: 900px;
      margin: auto;
      line-height: 1.8;
    }
    h1 {
      font-size: 2.6rem;
      margin: 1.5em 0 0.5em;
      text-align: center;
      animation: fadeIn 1s ease-in-out;
    }
    details {
      margin-top: 1em;
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 6px;
      background: rgba(200,200,200,0.05);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    details:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    summary {
      font-size: 1.2rem;
      font-weight: bold;
      cursor: pointer;
      transition: color 0.3s ease;
    }
    summary:hover {
      color: var(--primary-light);
    }
    summary::marker {
      font-size: 1.2em;
    }
    img.logo {
      display: block;
      margin: 0 auto 20px;
      width: 100px;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
      animation: popIn 0.8s ease forwards;
    }
    pre {
      padding: 14px;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.95em;
      border: 1px solid rgba(0,0,0,0.1);
      background: linear-gradient(135deg, #f4f4f4, #ffffff);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      border-radius: 8px;
      overflow: hidden;
      margin-top: 1em;
      animation: fadeIn 1.5s ease;
    }
    table th, table td {
      border: 1px solid rgba(0,0,0,0.1);
      padding: 10px;
      text-align: left;
      transition: background 0.3s ease;
    }
    table th {
      background: var(--accent);
    }
    table tr:hover td {
      background: rgba(200,200,200,0.1);
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes popIn {
      0% { transform: scale(0.8); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
  
    /* --- Tree view for nested sections --- */
    .guide-root { position: relative; }
    .guide-root details { position: relative; }
    /* Indent nested details and draw a vertical connector to parent */
    .guide-root details details {
      margin-left: 1rem;
      padding-left: 1rem;
      border-left: 2px solid rgba(139, 95, 191, 0.35); /* matches --primary-dark tone */
    }
    /* Add subtle branch markers before nested summaries */
    .guide-root details details > summary::before {
      content: "â””â”€";
      display: inline-block;
      margin-right: 0.5rem;
      opacity: 0.6;
    }
    /* Hover highlight flows through nested rows */
    .guide-root details:hover > summary { text-decoration: underline; text-underline-offset: 3px; }
    /* Keep tables and pre blocks readable on animated bg */
    .guide-root pre, .guide-root table {
      background: rgba(255, 255, 255, 0.9);
    }
    @media (prefers-color-scheme: dark) {
      .guide-root pre, .guide-root table {
        background: rgba(30, 30, 47, 0.9);
      }
    }

  </style>
</head>
<body>
  <div class="guide-root">
<canvas id="c" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:-1;"></canvas>
  <div style="text-align: center;"><img src="../assets/images/logo.png" alt="GRAPE logo" class="logo"></div>
  <h1>ğŸ‡ GRAPE | User Guide</h1>
  <p>Welcome! GRAPE is your <strong>GPT-Regulated Autonomous Productivity Enforcer</strong> â€” designed to help you stay focused, track your goals, and block distractions (especially in ChatGPT).</p>
  <p><strong>ğŸ“Œ Make sure to pin the GRAPE extension to your browserâ€™s toolbar.</strong> The badge icon updates in real time to reflect your current focus score and mode, and clicking it opens the popup for quick interactions.</p>
  
  <details open>
    <summary>ğŸŒ± Introduction</summary>
    <details open>
      <summary>ğŸŒ± Why I Made This</summary>
  <p>Plenty of apps let you block distracting websites â€” like <strong>Cold Turkey Blocker</strong> (my favorite, not sponsored) â€” but sometimes, you need those sites to be productive too. For example, YouTube is a huge distraction, but tools like <em>Unhook</em>, <em>YouTube Filter</em>, and <em>Channel Blocker</em> exist to help manage that.</p>
  <p>But ChatGPT is so new that we donâ€™t have any solid tools yet. And honestly, it can be a productivity trap. Itâ€™s way too easy to fall down rabbit holes â€” yet you need it to be your most productive self.</p>
  <p>I have ADHD and struggle with executive functioning in medical school, so I built this AI-powered extension to help regulate how you use AI to stay on track â€” because the world didnâ€™t have a system like thatâ€¦ until now.</p>
    </details>
    <details>
      <summary>ğŸš¦ What GRAPE Actually Does</summary>
<p>
  GRAPE is a smart productivity extension for ChatGPT. It works by scanning your most recent input (default: last 1000 characters) at set intervals, then uses AI to check if you're staying on-topic based on your chosen goal. If you go off-topic â€” or use a word from your custom blocklist â€” GRAPE blocks ChatGPT for a short time (default: 10 seconds).
  </p>
  <p>
  You stay in control: all settings like scan frequency, character limits, blocked words, and timeout durations are fully customizable. The idea isn't to stop you from using ChatGPT â€” it's to help you use it with intention and discipline. This is a tool for people who want to hold themselves accountable and avoid falling into rabbit holes. 
  </p>
  <p><strong>Discipline = Freedom.</strong></p>
  </details>
  </details>

  <details>
    <summary>ğŸ¯ Productivity & Gamification</summary>
    <details>
      <summary>ğŸ® Gamification & Chasing the High Score</summary>
  <p>Turn productivity into a game: each snippet of your work is reviewed by the ğŸ± Cat Judge, who hands out <strong>+1 point</strong> for staying focused and <strong>â€“1 point</strong> for going off track. Your willpower score ranges from <em>â€“5 to 10</em>, keeping you accountable while giving you a high score to chaseâ€”like a personal leaderboard challenge.</p>
    </details>
    <details>
      <summary>ğŸ’ª The Willpower Point System</summary>
<p>Your willpower score tracks how focused youâ€™ve been, ranging from <strong>â€“5 to 10</strong>. Every few minutes, the extension checks your latest snippet and asks the AI if you're still on task. You earn <strong>+1 point</strong> for staying on-topic and <strong>â€“1 point</strong> for drifting off or triggering a blocked word.</p>
  
  <p>If your score drops too low (by default â‰¤ 4), youâ€™ll be locked out from ChatGPT for a set durationâ€”like losing a life in a game. This gives you a chance to pause, reset, and try again. Small missteps wonâ€™t ruin your momentum, but consistent distraction has consequences. Itâ€™s designed to build long-term consistency, not punish perfection.</p>
    </details>
    <details>
      <summary>ğŸ”¥ Streak Tracking</summary>
<p>Tracks consecutive days of focused use (without uninstalling):</p>
  <ul>
    <li>â„ï¸ Ice (0 days)</li>
    <li>ğŸ‡ Grape (1â€“6 days)</li>
    <li>ğŸ”¥ Fire (7+ days)</li>
  </ul>

    </details>
  </details>

  <details>
    <summary>âš™ï¸ Using GRAPE</summary>
    <details>
      <summary>ğŸ§  Focus Modes</summary>
      <ul>
    <li><strong>Always On</strong>: Constant monitoring â€” GPT checks every snippet without interruption.</li>
    <li><strong>Timer</strong>: You set a fixed focus duration (<em>#</em> minutes). After timeâ€™s up, monitoring stops until you restart.</li>
    <li><strong>Cycle</strong>: One-time Relax â†’ Focus sequence. Pick <em>#</em> minutes of relax followed by <em>#</em> minutes of focus, then it automatically switches back to Always On (unlocked).</li>
  </ul>
    </details>
    <details>
      <summary>ğŸ”˜ Buttons & Inputs Overview</summary>
<ul>
    <li><strong>Goal Input</strong>: Type in your current focus goal (e.g., â€œMCATâ€, â€œcodingâ€). Displayed on your badge and saved automatically.</li>
    <li><strong>Focus Mode Selector</strong>: Choose between <em>Always On</em>, <em>Timer</em>, <em>Cycle</em> (Relax â†’ Focus), or turn it <em>Off</em>.</li>
    <li><strong>Duration Fields</strong>:
      <ul>
        <li><code>D</code> = Timer duration (minutes)</li>
        <li><code>G</code> = Relax phase (minutes)</li>
        <li><code>H</code> = Focus phase (minutes)</li>
      </ul>
    </li>
    <li><strong>Lock Toggles</strong>: Each mode can optionally be â€œlockedâ€ to prevent you from quitting early (ğŸ”’).</li>
    <li><strong>ğŸ’¾ Save Focus Settings</strong>: Applies your selected mode and durations immediately.</li>
    <li><strong>âš™ï¸ Settings</strong>: Opens the full configuration panel (scan interval, thresholds, API key, etc.).</li>
    <li><strong>ğŸ” Password</strong>: Enables the Extreme Lock modal to protect your UI behind a password.</li>
    <li><strong>ğŸ“˜ User Guide</strong>: Opens this help guide in a new tab.</li>
  </ul>
  </details>
    <details>
      <summary>âš™ï¸ Settings Panel</summary>
 <ul>
    <li><strong>Scan Character Limit</strong>: How many characters are sent to GPT each scan (100â€“4000). Default: 1000.</li>
    <li><strong>Scan Interval</strong>: How often the extension checks your ChatGPT tab (0.1â€“60 min).</li>
    <li><strong>OpenAI API Key</strong>: Paste your key here. Only the first and last few characters are shown (masked).</li>
    <li><strong>Block Duration</strong>: How long youâ€™ll be locked out (0.1â€“720 min) after going off-task.</li>
    <li><strong>Willpower Block Threshold</strong>: The score at which a lockout is triggered (â€“5 to 10).</li>
    <li><strong>ğŸ’¾ Save Settings</strong>: Stores your changes; button confirms with â€œâœ… Saved!â€.</li>
    <li><strong>ğŸ”’ Manage Blocked Sites</strong>: Opens a separate page where you can customize blocked URLs.</li>
    <li><strong>ğŸ’° Cost Estimate</strong>: Shows projected GPT usage cost per hour and per $1, based on your current scan interval and character limit.</li>
    <li><strong>Blocked Words</strong>: Words or phrases (one per line) that trigger an instant deduction if detected in your snippet.</li>
    <li><strong>Banned Word Check Interval</strong>: How often (in seconds) to scan for blocked words. Default: 10s.</li>
    <li><strong>User Notes</strong>: Local-only text field for personal reminders or context.</li>
  </ul>
  </details>
    <details>
      <summary>ğŸ’° Cost Estimate</summary>
<p>The <strong>Cost Estimate</strong> feature helps you understand how much using the extension will cost based on your current settings. It calculates two things:</p>
  
  <ul>
    <li><strong>Hourly Cost</strong>: An estimate of how much you're spending per hour while using ChatGPT through the extension.</li>
    <li><strong>Days-per-Dollar</strong>: How many days $1 of OpenAI credit can support, assuming you're consistently using ChatGPT with your configured scan interval and character limit.</li>
  </ul>
  
  <p>For example, if it says <code>1â€¯$/9â€¯days</code>, that means your current settings would let $1 cover about nine days of non-stop usage.</p>
  
  <h3>ğŸ“‰ How It's Calculated</h3>
  <ul>
    <li>Each scan uses a certain number of tokens, based on your character limit.</li>
    <li>The scan interval controls how frequently these scans occur.</li>
    <li>Scans are <strong>only triggered</strong> when:
      <ul>
        <li>You have a ChatGPT tab open</li>
        <li>A focus mode is active</li>
        <li>The visible text is at least 30 characters</li>
        <li>The snippet isnâ€™t identical to the last one (to avoid double-charging)</li>
      </ul>
    </li>
  </ul>
  
  <p>This makes sure you're only charged for meaningful, active useâ€”helping you get the most out of your API key without wasting money.</p>
    </details>
    <details>
      <summary>ğŸ”‘ API Key & Setup Tutorial</summary>
  <p>To power the on-topic/off-topic scoring, youâ€™ll need an OpenAI API key.â€¯All your settings, blocked lists, and scores are stored locally in your browserâ€”nothing is sent to us. Only the small snippets sent for GPT scoring go to OpenAI via your personal key. We donâ€™t monetize your dataâ€”you pay only for what you use on the API(no middle man), and we never see any of your content.</p>
  <p>To get a key:</p>
  <ol>
    <li>Visit the OpenAI dashboard and generate a new API key.</li>
    <li>Copy and paste it into the <strong>API Key</strong> field in Settings (only first and last characters are shown for safety).</li>
    <li>Watch this quick walkthrough: <a href="https://www.youtube.com/watch?v=SzPE_AE0eEo" target="_blank">How to Get an OpenAI API Key</a>.</li>
  </ol>
  </details>
    <details>
      <summary>ğŸ” Password</summary>
  <p>If you tend to change settings impulsively, the Extreme Lock feature helps you commit. When enabled, it locks down the entire popup UI and requires a password to make any changes.</p>
  
  <p>The first time you click the <strong>Password</strong> button, youâ€™ll be prompted to create and confirm a password. This password is securely saved (encrypted in browser storage) and will be required for any future edits.</p>
  
  <p>Once a password is set, the lock modal will present these options:</p>
  <ul>
    <li><strong>âœ… Continue</strong>: Temporarily unlock the UI after entering the correct password.</li>
    <li><strong>âŒ Delete Password</strong>: Permanently remove the password (requires re-entering it to confirm).</li>
    <li><strong>ğŸ”„ Reset Focus Mode Lock</strong>: Clears any active timer or cycle locks youâ€™ve applied.</li>
    <li><strong>ğŸ”’ Toggle Permanent Lock</strong>: Re-lock the UI immediately, even after unlocking.</li>
  </ul>    </details>
  </details>

  <details>
    <summary>ğŸ› ï¸ Support & Extras</summary>
    <details>
      <summary>ğŸ§¹ Reset / Emergency Tools</summary>
<ul>
    <li>Emergency unblock button on the block screen.</li>
    <li><strong>Emergency Console Reset</strong>: If the UIâ€™s unblock fails, open your browser console and run:
      <pre><code>function clearNow() {
  chrome.declarativeNetRequest.getDynamicRules(rules => {
    const ids = rules.map(r => r.id);
    if (!ids.length) return console.log("â„¹ï¸ No dynamic rules to clear.");
    chrome.declarativeNetRequest.updateDynamicRules(
      { removeRuleIds: ids, addRules: [] },
      () => console.log("âœ… Cleared dynamic rules:", ids)
    );
  });
}
clearNow();</code></pre>
    </li>
    <li>To use GRAPE purely as a word blocker, set a general goal like â€œFocusâ€ and increase the API scan interval to a large value (e.g., 999). This disables scoring while still enforcing blocked words.</li>
  </ul>
  </details>
    <details>
      <summary>ğŸ› ï¸ Troubleshooting</summary>
  <ul>
    <li><strong>Blocked while on-topic?</strong> Tweak scan length, goal wording, or threshold.</li>
    <li><strong>Locked out?</strong> Use Reset Lock or ensure footer isnâ€™t blocked by CSS.</li>
    <li><strong>API Issues?</strong> Double-check your key and reload the ChatGPT tab.</li>
    <li><strong>Score drops too fast?</strong> Raise the threshold or reduce scan frequency.</li>
  </ul>
  </details>
    <details>
      <summary>ğŸš€ Future Plans</summary>
  <p>GRAPE is just getting started. Hereâ€™s where it's heading:</p>
  
  <ul>
    <li><strong>Goal-Aware GPT Prompts Across All Sites</strong>: GRAPE will be able to scan your goal and apply it anywhere GPT is usedâ€”not just on ChatGPT. This could include embedded bots or redirected apps.</li>
  
    <li><strong>Supportive Prompt Injection</strong>: When redirected to ChatGPT during distraction, the extension could auto-send a message like:<br>
      <em>â€œThis user installed GRAPE to stay focused and avoid distractions. Their goal is <code>â€˜[Your Goal]â€™</code>. Please help keep them on track and motivated.â€</em>
    </li>
  
    <li><strong>Custom Redirect Messages</strong>: You'll be able to write a personalized message that shows on the block page when you're locked outâ€”motivational, humorous, or even a reminder of why you care.</li>
  
    <li><strong>Grace Period System</strong>: Instead of punishing every single slip-up, youâ€™ll be able to configure how many bad judgments (1, 2, or more) it takes before you lose willpower points or get blocked. This encourages resilience, not guilt.</li>
  
    <li><strong>Cleaner, More Intuitive UI</strong>: A design polish is coming to make the interface even more inviting and minimal, especially for new users.</li>
  
    <li><strong>Alternate API Support</strong>: Future builds may let you swap OpenAI for other providers like Gemini, Claude, or local modelsâ€”potentially saving money or running offline.</li>
  
    <li><strong>Optional Cost-Free Offline Mode</strong>: For users who want the scoring logic without relying on a paid API, an offline fallback mode could simulate scoring without external requests.</li>
  </ul>
  
  <p>If you have ideas, feedback, or want to help build, reach out! GRAPE is meant to grow with you ğŸ‡</p>
    </details>
    <details>
      <summary>ğŸ·ï¸ Badge Icons Explained</summary>
  <p>GRAPE uses emojis on the extension badge to give quick feedback on your focus state:</p>
  <table border="1" cellpadding="6" cellspacing="0" style="border-collapse: collapse;">
    <tr><th>Emoji</th><th>Meaning</th></tr>
    <tr><td>ğŸ§ </td><td><strong>Always On</strong> â€” GPT monitoring is active at all times.</td></tr>
    <tr><td>ğŸ•’</td><td><strong>Timer</strong> â€” You're in a timed focus session.</td></tr>
    <tr><td>â˜•</td><td><strong>Relax</strong> â€” You're on a break before focus begins.</td></tr>
    <tr><td>ğŸ’¼</td><td><strong>Work</strong> â€” Dedicated work/focus mode.</td></tr>
    <tr><td>ğŸš«</td><td><strong>Off</strong> â€” No monitoring is active.</td></tr>
    <tr><td>â›”</td><td><strong>Blocked</strong> â€” A blocked site or word was detected.</td></tr>
    <tr><td>ğŸ”’</td><td><strong>UI Locked</strong> â€” Extreme Lock engaged.</td></tr>
    <tr><td>â„ï¸</td><td><strong>0-Day Streak</strong> â€” Fresh start after reinstall.</td></tr>
    <tr><td>ğŸ‡</td><td><strong>1â€“6 Day Streak</strong> â€” You're on a roll.</td></tr>
    <tr><td>ğŸ”¥</td><td><strong>7+ Day Streak</strong> â€” A full week of consistency!</td></tr>
  </table>
  </details>
  </details>

  <footer>
    <em>Note: This extension, including code snippets and images, was generated with assistance from AI (ChatGPT).</em>
    <br>â€” <strong>Robert Remedios</strong>
  </footer>
<script>
  (() => {
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });

    // --- Performance-first knobs ---
    // Lower DPR and coarser grid = big FPS gains.
    const DPR_CAP = 1.15;                        // cap device pixel ratio
    const GRID_SCALE = 10;                       // px per velocity cell (was 6)
    const INITIAL_PARTICLES = 6000;              // was 12000

    let DPR = Math.max(1, Math.min(DPR_CAP, window.devicePixelRatio || 1));

    // Pre-rendered glow sprite (drawn once, blitted many times)
    let glowSprite, glowSize;
    function makeGlowSprite() {
      glowSize = Math.round(3.0 * DPR);          // base radius in device px
      const s = glowSize * 2 + 1;
      const off = document.createElement('canvas');
      off.width = off.height = s;
      const gctx = off.getContext('2d');
      const grd = gctx.createRadialGradient(glowSize, glowSize, 0, glowSize, glowSize, glowSize);
      grd.addColorStop(0.00, 'rgba(180, 0, 255, 0.55)');
      grd.addColorStop(0.50, 'rgba(140, 0, 200, 0.22)');
      grd.addColorStop(1.00, 'rgba(40, 0, 70, 0.00)');
      gctx.fillStyle = grd;
      gctx.fillRect(0, 0, s, s);
      glowSprite = off;
    }

    // Resize
    function resize() {
      const w = Math.floor(innerWidth * DPR);
      const h = Math.floor(innerHeight * DPR);
      canvas.width = w; canvas.height = h;
      canvas.style.width = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
      flow.resize(w, h);
    }
    window.addEventListener('resize', resize);

    // Simple flow field (coarser + fewer smooth passes)
    const flow = (() => {
      let W = 0, H = 0, cols = 0, rows = 0, scale = GRID_SCALE; 
      let vx, vy; 
      const idx = (x,y) => x + y * cols;
      function resize(w,h){
        W=w; H=h; cols = Math.ceil(W/scale); rows = Math.ceil(H/scale);
        vx = new Float32Array(cols*rows);
        vy = new Float32Array(cols*rows);
      }
      function addVelocity(px,py,fx,fy,radiusPx){
        const r = Math.max(4,(radiusPx||40)*DPR)/scale;
        const cx = px/scale, cy = py/scale; const r2 = r*r;
        const minx = Math.max(0, (cx - r)|0), maxx = Math.min(cols-1, (cx + r)|0);
        const miny = Math.max(0, (cy - r)|0), maxy = Math.min(rows-1, (cy + r)|0);
        for(let y=miny;y<=maxy;y++){
          for(let x=minx;x<=maxx;x++){
            const dx = x-cx, dy=y-cy; const d2 = dx*dx+dy*dy; if(d2>r2) continue;
            const fall = Math.exp(-d2/(r2*0.75)); const i=idx(x,y);
            vx[i]+=fx*fall; vy[i]+=fy*fall;
          }
        }
      }
      function step(){
        const visc=0.95; const smoothIters=1; // fewer iters
        for(let k=0;k<smoothIters;k++){
          for(let y=1;y<rows-1;y++){
            for(let x=1;x<cols-1;x++){
              const i=idx(x,y), il=idx(x-1,y), ir=idx(x+1,y), iu=idx(x,y-1), id=idx(x,y+1);
              vx[i] = (vx[i] + 0.15*(vx[il]+vx[ir]+vx[iu]+vx[id]-4*vx[i]));
              vy[i] = (vy[i] + 0.15*(vy[il]+vy[ir]+vy[iu]+vy[id]-4*vy[i]));
            }
          }
        }
        for(let i=0;i<vx.length;i++){ vx[i]*=visc; vy[i]*=visc; }
      }
      function velocityAt(px,py){
        const gx = Math.max(0, Math.min(cols-1.001, px/scale));
        const gy = Math.max(0, Math.min(rows-1.001, py/scale));
        const x0 = gx|0, y0 = gy|0, x1 = Math.min(x0+1, cols-1), y1 = Math.min(y0+1, rows-1);
        const sx = gx-x0, sy = gy-y0; const i00=idx(x0,y0), i10=idx(x1,y0), i01=idx(x0,y1), i11=idx(x1,y1);
        const vx0=vx[i00]*(1-sx)+vx[i10]*sx, vx1=vx[i01]*(1-sx)+vx[i11]*sx;
        const vy0=vy[i00]*(1-sx)+vy[i10]*sx, vy1=vy[i01]*(1-sx)+vy[i11]*sx;
        return {x:vx0*(1-sy)+vx1*sy, y:vy0*(1-sy)+vy1*sy};
      }
      return { resize, addVelocity, step, velocityAt };
    })();

    // Particles (draw via sprite blits instead of per-particle gradients)
    const particles = (() => {
      let PCOUNT = INITIAL_PARTICLES;
      let pts, life;
      function alloc(){
        pts = new Float32Array(PCOUNT*4);
        life= new Float32Array(PCOUNT);
      }
      function reset(i){
        pts[i]   = Math.random()*canvas.width;
        pts[i+1] = Math.random()*canvas.height;
        pts[i+2] = (Math.random()-0.5)*0.15;
        pts[i+3] = (Math.random()-0.5)*0.15;
        life[i>>2] = Math.random()*0.2;
      }
      function init(){ alloc(); for(let p=0;p<PCOUNT;p++) reset(p<<2); }
      function step(dt){
        const drag=0.986, decay=0.987;
        for(let k=0,j=0;k<PCOUNT;k++,j+=4){
          const x=pts[j], y=pts[j+1];
          const v=flow.velocityAt(x,y);
          pts[j+2] = pts[j+2]*drag + v.x*0.9;
          pts[j+3] = pts[j+3]*drag + v.y*0.9;
          pts[j]   = x + pts[j+2]*dt;
          pts[j+1] = y + pts[j+3]*dt;
          if(pts[j]<0) pts[j]+=canvas.width; else if(pts[j]>=canvas.width) pts[j]-=canvas.width;
          if(pts[j+1]<0) pts[j+1]+=canvas.height; else if(pts[j+1]>=canvas.height) pts[j+1]-=canvas.height;
          life[k]*=decay;
        }
      }
      function excite(px,py,strength){
        const r = Math.max(canvas.width, canvas.height)*0.12; const r2=r*r; const s=Math.min(1.4, Math.max(0.25, strength||1));
        for(let k=0,j=0;k<PCOUNT;k++,j+=4){
          const dx=pts[j]-px, dy=pts[j+1]-py; const d2=dx*dx+dy*dy; if(d2<r2){ life[k]=Math.min(1, life[k]+Math.exp(-d2/(r2*0.6))*s); }
        }
      }
      function draw(ctx){
        ctx.globalCompositeOperation='lighter';
        for(let k=0,j=0;k<PCOUNT;k++,j+=4){
          const a=life[k]; if(a<0.02) continue;
          const x=pts[j], y=pts[j+1];
          ctx.globalAlpha = Math.min(0.9, a*0.9);
          const r = glowSize*(1 + a*2.2);
          ctx.drawImage(glowSprite, x - r, y - r, r*2, r*2);
        }
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation='source-over';
      }
      function adaptParticles(target){
        target = Math.max(1500, Math.min(12000, target|0));
        if(target === PCOUNT) return;
        PCOUNT = target; alloc(); init();
      }
      return { init, step, draw, excite, adaptParticles };
    })();

    // Input
    const pointer = { x:0, y:0, vx:0, vy:0, speed:0 };
    function setPointer(e){
      const rect = canvas.getBoundingClientRect();
      const x = ((e.touches? e.touches[0].clientX : e.clientX) - rect.left) * DPR;
      const y = ((e.touches? e.touches[0].clientY : e.clientY) - rect.top) * DPR;
      pointer.vx = x - pointer.x; pointer.vy = y - pointer.y;
      pointer.speed = Math.hypot(pointer.vx, pointer.vy);
      pointer.x = x; pointer.y = y;
    }
    window.addEventListener('mousemove', e=>{ setPointer(e); flow.addVelocity(pointer.x,pointer.y,pointer.vx*0.12,pointer.vy*0.12,60); particles.excite(pointer.x,pointer.y, Math.min(1.1, 0.2 + pointer.speed/60)); });
    window.addEventListener('touchmove', e=>{ e.preventDefault(); setPointer(e); flow.addVelocity(pointer.x,pointer.y,pointer.vx*0.12,pointer.vy*0.12,70); particles.excite(pointer.x,pointer.y, Math.min(1.2, 0.25 + pointer.speed/40)); }, { passive:false });

    // Adaptive performance controller
    let last = performance.now();
    let fpsEMA = 60; // exponential moving average
    function frame(t){
      const dtms = Math.min(33, t-last); last=t; const dt = dtms*0.06;
      const isDark = matchMedia && matchMedia('(prefers-color-scheme: dark)').matches;
      ctx.fillStyle = isDark ? 'rgba(0,0,0,0.28)' : 'rgba(248,250,252,0.28)';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      flow.step();
      particles.step(dt);
      particles.draw(ctx);

      // Adapt: if fps < 45, drop particles; if > 58, add a bit back
      const fps = 1000/Math.max(1, dtms); fpsEMA = fpsEMA*0.9 + fps*0.1;
      if ((performance.now()|0)%500 < 16) { // check ~2x/sec
        if (fpsEMA < 45) {
          particles.adaptParticles((INITIAL_PARTICLES * 0.75)|0);
          DPR = Math.max(1, DPR*0.95); // nudge DPR down
          resize(); makeGlowSprite();
        } else if (fpsEMA > 58 && DPR < DPR_CAP){
          // small quality nudge up
          DPR = Math.min(DPR_CAP, DPR*1.02);
          resize(); makeGlowSprite();
        }
      }
      requestAnimationFrame(frame);
    }

    // Boot
    makeGlowSprite();
    resize();
    particles.init();
    // Seed a small swirl
    const cx = () => canvas.width*0.5, cy = () => canvas.height*0.5;
    for (let a=0; a<Math.PI*2; a+=Math.PI/24){
      const r = Math.min(canvas.width, canvas.height)*0.25;
      const x = cx() + Math.cos(a)*r; const y = cy() + Math.sin(a)*r;
      const fx = -Math.sin(a)*2.0, fy = Math.cos(a)*2.0;
      flow.addVelocity(x,y,fx,fy,35);
    }

    requestAnimationFrame(frame);
  })();
  </script>
  </div>
</body>
</html>
